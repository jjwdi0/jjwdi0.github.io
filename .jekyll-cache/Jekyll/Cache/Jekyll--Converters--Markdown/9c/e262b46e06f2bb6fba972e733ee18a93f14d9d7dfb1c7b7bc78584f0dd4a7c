I"<p>UCPC/ICPC 팀 연습을 몇 번 진행했는데, 셋에 있는 문제를 모두 정리하기에는 아직 모르는 문제도 많아서 아는 문제나 흥미로웠던 문제 위주로 정리하려 한다.</p>

<hr />

<h3 id="2015-tsukuba-regional-i-routing-a-marathon-race">2015 Tsukuba Regional I. Routing a Marathon Race</h3>
<p>$N$이 40이라 플로우 비슷하게 풀리려나 생각했는데, 놀랍게도 백트래킹이 정해다. 단 커팅을 잘 해야 하는데, 현재 위치한 정점 번호 $x$와 현재 정점에 오기 전까지 있었던 정점과 그와 인접한 정점 집합 $Y$를 들고 있자. 만약 최적 경로의 일부분이 $u-v-w$라 하면, $u$와 $w$는 그래프 상에서 연결되어 있을 수 없다. 만약 연결되어 있다면 $u$에서 바로 $w$로 가는 것이 이득이기 때문이다.</p>

<p>이를 이용하면, 정점 $x$에서 다음에 갈 정점을 선택할 때 $y$에 들어있는 정점을 선택하면 절대 최적의 경로를 찾을 수 없음을 알 수 있다. 이를 이용하면 시간 안에 해결할 수 있음을 보장할 수 있다. 시간복잡도를 증명하는 과정이 인상깊다고 생각되어서 이 부분은 직접 해 보는 것을 추천.</p>

<h3 id="2015-tsukuba-regional-j-post-office-investigation">2015 Tsukuba Regional J. Post Office Investigation</h3>
<p>1번 정점에서는 ‘모든 정점을 방문할 수 있고’, 1번 정점에서 $v$번 정점까지 갈 때 ‘반드시 거쳐야 하는 정점’을 구해야 하는 문제다. 이러한 작업을 해 주는 자료구조를 dominator tree라고 한다. 연습 당시에는 몰라서 손도 못 댔는데, dominator tree의 개념을 접하면 문제를 tree에서 LCA를 빠르게 구하는 문제로 바꿀 수 있기 때문에 쉽게 풀린다.</p>

<h3 id="2015-tsukuba-regional-k-min-max-distance-game">2015 Tsukuba Regional K. Min-Max Distance Game</h3>
<p>문제를 결정 문제로 바꿔서 풀자. 구체적으로, 문제를 ‘Alice가 남은 두 돌의 거리를 $x$ 이상으로 남게 할 수 있는가’라는 형태로 바꿔서 생각하자. 이를 쉽게 해결하기 위해 돌의 위치로 그래프를 구성하는데, 두 돌의 거리가 $x$보다 작으면 간선을 이어주는 식으로 만들자. 그러면 두 플레이어는 각 턴마다 정점을 하나 없애면서 그와 연결된 간선을 모두 제거하는 것과 같고, Alice의 경우 그래프의 모든 간선을 지워야 하며 Bob은 반대로 그래프의 간선을 남기는 것을 목적으로 게임을 진행해야 한다.</p>

<p>몇 가지 경우를 살펴보자. 만약 Minimum Vertex Cover의 크기가 Alice가 충분히 지울 정도로 작다면, Alice는 해당 정점만 없애면 이길 수 있다. 그렇지 않고 Maximum Clique의 크기가 Alice가 지울 수 있는 정점의 수보다 크면, Alice는 모든 간선을 지울 수 없으므로 진다. 두 경우가 동시에 발생하는 경우는 없고, 둘 다 발생하지 않는 경우에는 마지막 턴을 진행하는 사람이 이긴다. 그래프가 특수한 형태이므로 Minimum Vertex Cover와 Maximum Clique의 크기는 $O(N)$에 구할 수 있다. 이를 이용하면 빠른 시간 안에 문제를 해결할 수 있다.</p>

<p>위의 내용에 대한 증명은 <a href="https://www.slideshare.net/irrrrr/icpc-2015-tsukuba-unofficial-commentary">https://www.slideshare.net/irrrrr/icpc-2015-tsukuba-unofficial-commentary</a>에서 확인할 수 있다.</p>

<h3 id="boj-10562---나이트">BOJ 10562 - 나이트</h3>
<p>$M$이 작고 $N$이 굉장히 크다. $M$을 고정하면 답이 점화식의 형태로 구해질 것이라 추측할 수 있고, 실제로도 맞다. 이전 두 열이 결정되면 가능한 다음 열의 상태를 구할 수 있으니 이를 이용하면 행렬 곱셈으로 문제를 해결할 수 있다. 이 경우 $O(2^{6M}\log{N})$ 시간복잡도로 구할 수 있다.</p>

<p>행렬로 점화식을 계산할 수 있으니, Berlekamp-Massey Algorithm을 적용할 수 있다. 초기 값들은 bitmask dp를 이용해 구할 수 있으니, 이를 이용하면 시간복잡도를 개선할 수 있다. 실제로 BOJ에서는 0ms로 통과할 수 있다.</p>

<h3 id="boj-10566---도장-도장">BOJ 10566 - 도장 도장</h3>
<p>도장을 두 번째로 찍을 때 첫 번째로 찍을 때와 비교해서 움직인 좌표를 벡터 $(a, b)$로 두자. 그럼 각 점에 대해서 $(a, b)$만큼 움직였을 때 해당 점에 이미 도장이 찍혀있거나, 만약 그렇지 않다면 $-(a, b)$만큼 움직인 곳에 도장이 찍혀있어야 한다. 두 조건 모두 만족하지 않는다면 그때의 $(a, b)$는 올바르지 않은 벡터가 되고, 도장이 찍힌 모든 점이 두 조건 중 하나를 만족하면 $(a, b)$는 답의 후보가 될 수 있다. 각 가능한 $(a, b)$마다 초기 도장의 위치로 가능한 점의 수를 세어서 그 중 최솟값을 구하면 된다. 이렇게 문제를 해결하려 하면 $O(W^2L^2)$의 시간복잡도가 되어 TLE를 받을 것이다.</p>

<p>여기서 주어진 점들의 convex hull을 고려하자. 이때 첫 도장에 포함되어 있고 그 점이 두 번째 도장으로 옮겨 가는 점 두 개가 모두 convex hull에 있는 점이 있다. 이를 이용해 convex hull 상에서 구할 수 있는 $(a, b)$들만 답의 후보로 추릴 수 있고, 이러한 벡터들로만 시도하면 AC를 받을 수 있다.</p>

<h3 id="boj-10567---towers">BOJ 10567 - Towers</h3>

<h3 id="g-guest-student">G. Guest Student</h3>
<p>이번 셋에서 제일 쉬운 문제.</p>

<h3 id="h-harder-satisfiability">H. Harder Satisfiability</h3>

<h3 id="i-interval-free-permutations">I. Interval-Free Permutations</h3>
<p>풀이를 봤더니 어떻게 되는 지 잘 이해되지는 않았다. 백준에 보니까 0ms로 맞으신 분이 있던데 어떻게 푸신 건지 궁금..</p>

<h3 id="j-js-minification">J. JS Minification</h3>
<p>문제가 좀 끔찍하게 생겨서 안 보고 있었는데 풀만한 문제가 다 떨어져서 끝나기 80분 전쯤에 잡았다. 문제 지문도 길고, 요구하는 것도 많아서 구현까지 20~30분 걸리고, 그 뒤로도 몇 가지 테스트케이스를 넣어 보면서 제출해봤지만 못 맞췄다. 끝나고 다시 풀어봤는데 기존 풀이대로 내면 TLE를 받았겠지만 결과적으로 많이 고치지 않고 AC를 받을 수 있었다. 그냥 쌩으로 구현하는 문제 치고 난이도가 높은 편인 듯. 제발 이런 문제는 안 나왔으면..</p>

<h3 id="k-king-kogs-reception">K. King Kog’s Reception</h3>
<p>공주가 왕을 만나는 시간을 수식으로 잘 표현하는 것이 핵심이다. 이를 알면 문제가 구간 쿼리를 빠르게 계산하는 문제임을 알 수 있고, segment tree와 lazy propagation을 이용해 해결할 수 있다. 대회 때 이 문제를 푼 친구는 정해와 다른 방법으로 푼 것 같은데 그건 나중에 좀 더 고민해 봐야겠다.</p>

<h3 id="l-lazyland">L. Lazyland</h3>
<p>G 다음으로 쉬운 문제.</p>

<h3 id="m-minegraphed">M. Minegraphed</h3>
<p>문제를 보면 어떤 게임이 떠오른다.. 반례 없는 깔끔한 풀이를 만들기 상당히 어려웠고, 맵이 3차원이라 그리기도 어려웠다. 코딩이 복잡할 것 같아서 좀 늦게 잡았는데, 이 문제를 빨리 잡았으면 그래도 문제 한 개 정도는 더 풀었을 것 같다.</p>

<p>주어진 그래프를 SCC들로 분해한 다음, 위상 정렬을 통해 각 SCC가 있어야 할 층을 결정한 후 outgoing edge가 있으면 도달할 수 있도록 길을 열어주고 그렇지 않은 경우 길을 막아주면 된다. 다행이도 맵 크기 제한은 너그러운 편이라 생각보다 쉽게 구현 가능하다.</p>

<hr />
<p>마지막에 J를 풀지 못 한게 너무 아쉬웠다. B도 general matching이 팀노트에 들어갈 것을 생각하면 시도해보지 못한 것도 약간 아쉽다. J나 M같은 구현이 귀찮은 문제를 끈기 있게 잡고 푸는 연습을 해야 할 듯.</p>
:ET