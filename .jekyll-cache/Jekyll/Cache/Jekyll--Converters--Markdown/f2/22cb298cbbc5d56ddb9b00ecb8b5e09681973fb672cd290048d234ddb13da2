I"<hr />

<h3 id="boj-13894---binary-strings"><a href="https://www.acmicpc.net/problem/13894">BOJ 13894 - Binary Strings</a></h3>
<p>길이가 $n$이고 1이 연속으로 나타나지 않는 문자열의 수는 $f_{n+2}$와 같다. (단, $f_n$은 $n$번째 피보나치 수) 문제는 결국 $f_{K+2}+f_{2K+2}+…$를 빠르게 구하는 것으로, 이는 행렬 거듭제곱을 이용해 해결할 수 있다. 행렬이 모두 2X2 크기이므로 각 테스트케이스마다 $O(\log{N})$에 해결 가능하다.</p>

<h3 id="boj-8131---ploughing"><a href="https://www.acmicpc.net/problem/8131">BOJ 8131 - Ploughing</a></h3>
<p>가장 마지막에 가로줄을 없앤다고 가정하자. 이때 1XK 크기의 가로줄을 마지막에 없애면, K의 크기가 클수록 이득임을 알 수 있다. 이를 위해, 세로선 두 개를 고정하고 위아래 행을 그리디하게 없애자. 그리디하게 행을 제거하면, 남은 위아래 행은 제거 불가능하기 때문에 양 옆 열 중 하나를 제거해야 한다. 이러한 작업을 DP를 이용해 수행하면, 양 옆 열 간격이 줄어들수록 가능한 행 구간이 감소하므로 시간복잡도 $O(NM)$에 해결할 수 있다.</p>

<h3 id="boj-15313---정과프-해적단"><a href="https://www.acmicpc.net/problem/15313">BOJ 15313 - 정과프 해적단</a></h3>
<p>해체기의 범위로 가능한 의미 있는 경우의 수는 $O(N^2)$밖에 없음을 알 수 있다. 이렇게 범위를 지정하고 나면, x좌표 기준으로 정렬한 후 세그먼트 트리를 이용해 LIS를 구하는 것과 비슷하게 $O(N\log{N})$에 모을 수 있는 최대 가치 합을 구할 수 있다.</p>

<p>이렇게 하면 $O(N^3\log{N})$이므로, 좀 더 줄여야 한다. 구간 $[l, r]$이 가치 $M$ 이상을 모을 수 있는 해체기의 구간이라면, 같은 $l$값을 가지는 구간 중 구간 길이가 $r-l+1$보다 큰 구간은 무조건 가치 $M$ 이상을 모을 수 있을 것이다. 이를 이용하면 투 포인터를 사용할 수 있다. 구간의 양쪽이 단조증가하므로, $O(N^2\log{N})$에 전체 문제를 해결할 수 있다.</p>

<h3 id="boj-5820---경주"><a href="https://www.acmicpc.net/problem/5820">BOJ 5820 - 경주</a></h3>
<p>Centroid Decomposition 연습문제로 잘 알려진 문제다. 여기서는 이를 사용하지 않고 해결하는 방법을 설명하겠다.</p>

<p>편의상 1번 정점을 트리의 루트라고 생각하자. 각 정점마다 (높이, 1번 정점으로부터의 거리)를 저장하면, 어떤 정점 $p$와 자식노드 $x, y$에 대해 $x, y$에서 유래하여 $p$를 거치는 경로를 고려해줄 수 있다. $x, y$에는 각 정점이 루트인 서브트리에 대한 모든 정보를 가지고 있다고 가정하면, 작은 집합에서 큰 집합으로 합쳐주는 기법을 이용해 $O(N\log{N})$번의 병합으로 모든 자식노드의 정보를 합쳐줄 수 있다. 정보를 저장할 때에는 <code class="highlighter-rouge">std::map</code>을 이용하면 쉽게 처리할 수 있고, 이때의 시간복잡도는 $O(N\log^2{N})$이다.</p>

<h3 id="본선-b-던전-지도">본선 B. 던전 지도</h3>
<p>목적지에서 반대로 간다고 생각하면, 각 행마다 가능한 위치가 구간 형태로 나오며, 이는 단조 감소함을 알 수 있다. <a href="https://www.acmicpc.net/problem/14870">KOI 17 조개 줍기</a> 문제와 유사하다고 느꼈는데, 구간이 단조 감소/증가한다는 점을 파악하는게 훨씬 쉬워서 그런지 생각보다 많은 팀이 해결했다. A에서 말렸지만 B, C를 빠르게 해결해서 이때부터 안정을 찾을 수 있었던 것 같다.</p>

<h3 id="본선-d-소가-길을-건너간-이유-2020">본선 D. 소가 길을 건너간 이유 2020</h3>
<p>문제 이름은 <a href="https://www.acmicpc.net/category/396">USACO 2017 February Contest</a>의 오마주다.</p>

<p>간선을 $N+M-1$개 이으면 전체 그래프는 트리 형태가 되고, 그때의 모든 정점 쌍 간의 거리 합을 최소화하는 것이라 매우 어려울 줄 알았다. 문제를 조금 보다가 두 쪽 정점에 순서를 매겨서, 그 둘을 잇는 간선이 있을 때 전체 트리에서 그 간선을 통과하는 정점 쌍의 개수를 더해주면 해결할 수 있을 것이라는 생각을 했다. 이때 어느 쪽 정점이 연속으로 사용되었는지를 체크하면 되고, 약간 복잡한 $O(NM)$ DP 풀이가 나왔다. 실제로는 한 번 틀렸는데, 처음에는 함수 호출을 이용해 memoization으로 해결하려 해서 TLE를 받았기 때문이었다. 반복문으로 바꾸니까 빠른 시간 안에 해결할 수 있었다.</p>

<h3 id="본선-f-애완-트리">본선 F. 애완 트리</h3>
<p>이 문제랑 I랑 교대로 보면서 고민했는데, I는 직선일 때의 답을 원형에서의 답으로 바꾸려고 시도했는데 잘 안 돼서 F를 중점적으로 고민했다. $f(x)$를 트리의 지름을 $x$ 이하가 되게 하는 경우의 수로 두면, 주어진 문제의 답은 $f(E)-f(S-1)$을 계산하는 것이므로 이 아이디어를 바탕으로 생각을 했다. 이제 트리에서 지름의 길이가 $x$를 넘지 않도록 유지하는 경우의 수를 구해야 했는데, DP를 이용해서 각 정점마다 해당 정점이 서브트리일 때 리프에서의 거리 중 최댓값이 $c$인 경우를 모두 저장했다. 이제 $dp(u, c)$ 값을 이용해 $dp(root, c’)$의 값을 구해야 했는데, 이 부분이 잘 안 돼서 팀원과 오랜 시간 동안 고민을 했다. 이때 될 것 같은 풀이가 나왔고, 20분 정도 구현하고 제출하고 틀리고를 반복해서 대회 종료 약 한 시간 전에 맞을 수 있었다. DP 부분은 침착하게 잘 생각하면 그렇게 오래 걸릴 부분은 아니었던 것 같은데, 이상한 방향으로 생각이 고정되어서(FFT같은 것들이 생각났다…) 시간이 지체된 것 같아서 약간 아쉬웠다.</p>

<hr />
<p>예선 올솔브, 본선 6솔브로 나름 만족스러운 결과였지만, H와 G는 거의 다 풀었는데 못 풀었고, I도 정해와 비슷한 방향으로 생각했지만 시간이 부족해서 못 풀었다는 생각이 들어 아쉽다. H는 xudyh’s sieve를 사용하는 문제였지만, 그걸 짜본 적 있는 팀원과 내가 가진 지식을 합쳤으면 풀 수도 있었으나 그러지 못했다. G도 다른 팀원이 코딩을 했는데 중간에 말려서 제출하지 못했는데, 차라리 단순 코딩을 내가 맡고 I 같은 문제를 맡겼더라면 1~2 솔브 정도는 더 나올 수 있지 않았을까 하는 생각이 든다. 아쉬움도 남지만 뿌듯함도 남는 대회는 처음인 것 같다.</p>

<p>앞으로 남은 SCPC나 ICPC도 열심히 해서 잘 마무리하면 좋겠다!</p>
:ET