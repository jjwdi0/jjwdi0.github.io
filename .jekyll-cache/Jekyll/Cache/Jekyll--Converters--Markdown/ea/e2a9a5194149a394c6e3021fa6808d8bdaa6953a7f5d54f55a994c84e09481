I"<p>올해 ICPC를 또 나갈 것 같다. 이제부터는 팀연습 하고 기록을 남겨두려고 하는데, 간단한 타임라인 + 문제 설명 + 내가 뭘 했는가 를 중점적으로 정리할 것 같다.</p>

<p><a href="&quot;https://www.acmicpc.net/category/detail/1176&quot;">CERC 2013(BOJ 링크)</a></p>

<hr />

<h3 id="b-what-does-the-fox-say-010">B. What does the fox say? (0:10)</h3>
<p>옛날에 The Fox 노래가 유행했을 시절인 것 같다. 문자열이 주어지면 그 문자열에서 몇 개 빼서 남는 부분 출력하면 된다.</p>

<p>대회 때 내가 해결한 문제가 아니라 끝나고 다시 풀어봤는데, 한 줄을 입력받는 작업이 잘 되지 않았다. <code class="highlighter-rouge">getline(cin, x)</code> 을 좀 더 공부해야겠다.</p>

<h3 id="l-bus-011">L. Bus (0:11)</h3>
<p>사람이 절반 하고 반 명 내리는데 다치는 사람이 없어야 한다. (ㄷㄷ) 그냥 $2^n-1$을 찍으면 된다.</p>

<h3 id="f-draughts-111">F. Draughts (1:11)</h3>
<p>L을 푼 후 E를 팀원이 시도했는데 WA를 받았다. 대략 한 시간 지날 때까지 고민하다가 답이 안 나와서, 쉽게 풀리는 F를 그 다음으로 풀었다. F를 내가 안 풀어서 모르지만, 처음부터 E 대신 풀이가 확실한 F를 먼저 시도했어야 할 것 같은 생각이 든다.</p>

<h3 id="c-magical-gcd-116">C. Magical GCD (1:16)</h3>
<p>어떤 수열 A에서 연속된 구간이 이루는 gcd 값의 개수는 생각보다 많지 않다. 이를 이용하면 어렵지 않게 풀 수 있다. 난 <code class="highlighter-rouge">std::map</code> + DP로 풀었다.</p>

<p>연습 때는 팀원이 풀었는데, 범위를 잘못 알아서 세 번이나 틀렸다.</p>

<h3 id="k-digraphs-151">K. Digraphs (1:51)</h3>
<p>일단 예제 입력부터 아득하다… 인접하게 놓일 수 있는 알파벳들로 그래프를 구성하면, 그 그래프에서 최장 경로를 찾아주면 된다. 이때 사이클이 있는 경우와 없는 경우로 나뉘는데, 사이클이 있으면 20X20 크기만큼 그 사이클을 출력해주면 되고, 사이클이 없다면 DAG에서 DP로 최장 거리를 구해주면 된다. 생각하는 건 어렵지 않은데 손이 귀찮은 문제.</p>

<h3 id="i-cranes-207">I. Cranes (2:07)</h3>
<p>같은 크기의 인접한 구간 두 개를 잡아서 위치를 바꾸는 행위를 반복해 정렬하는 문제다. 구간 두 개를 바꾼다는 것과 $n \leq 10,000$인 것에서 splay tree를 생각했으나 푼 팀이 많아서 믿음을 가지고 $O(N^2)$을 돌려서 맞았다.</p>

<h2 id="boj-5476---장난감-동물">BOJ 5476 - 장난감 동물</h2>
<p>상당히 귀찮게 생긴 문제다. $B$의 값마다 다르게 풀어야 해서 세 문제를 푼다고 생각하면 된다. (아마 서브태스크 쉽게 나누려고 한 것 같다)</p>

<ul>
  <li>$B$가 1인 경우</li>
</ul>

<blockquote>
  <blockquote>
    <p>일차원 좌표 상에서 문제를 푸는 것과 같으니, 단순 이분 탐색으로도 맞을 수 있다. 이 부분은 패스.</p>
  </blockquote>
</blockquote>

<ul>
  <li>$B$가 2인 경우</li>
</ul>

<blockquote>
  <blockquote>
    <p>이차원 좌표에서, $N$개의 점이 있는데 각각을 중심으로 하는 대각선 길이 $2D$의 마름모 안에 있는 점들의 수를 모두 합한 값을 출력하면 된다.</p>
  </blockquote>
</blockquote>

<blockquote>
  <blockquote>
    <p>마름모가 나오는 계산기하 문제는, 점 $(x, y)$를 점 $(x-y, x+y)$로 변환하는 테크닉이 매우 유용하다. 이렇게 변환하면 마름모가 정사각형이 되어, 문제를 풀기 수월해지기 때문이다. 이러한 변환을 거치면 문제는 각각의 점을 중심으로 하는 한 변의 길이가 $2B$인 정사각형 안에 있는 점들의 수를 모두 합한 값을 구하는 것이 된다.</p>
  </blockquote>
</blockquote>

<blockquote>
  <blockquote>
    <p>이는 여러 가지 방법이 있는데, 본인은 merge sort tree를 이용해 해결하였다. 주어지는 점들을 정렬하여 sliding window 기법을 이용하면 일반적인 세그트리로도 문제를 해결할 수 있다.</p>
  </blockquote>
</blockquote>

<ul>
  <li>$B$가 3인 경우</li>
</ul>

<blockquote>
  <blockquote>
    <p>삼차원의 경우에는 문제가 어려울 것 같지만, 좌표의 범위가 크지 않아 생각보다 간단하게 해결할 수 있다.</p>
  </blockquote>
</blockquote>

<blockquote>
  <blockquote>
    <p>각 좌표를 $(x, y, z)$에서 $(x, y-z, y+z)$로 바꾸면, 각각의 $x$좌표마다 $B$가 2인 경우에 대해 문제를 푼다고 생각할 수 있다. 이는 이차원 누적합 배열로 충분히 할 수 있다.</p>
  </blockquote>
</blockquote>

<p>$B=2$인 경우만 잘 해결하면 무리 없이 풀 수 있는 문제이다.</p>

<hr />

<h2 id="boj-10129---작은-새">BOJ 10129 - 작은 새</h2>
<p>$Q$의 범위가 아주 작으니, 각각에 대해 $O(N)$ 정도에만 처리하면 문제를 풀 수 있을 것이라 생각할 수 있다.</p>

<p>일직선상에서 방향이 정해져 있으므로 DP로 점화식을 세울 수 있다. $D[i]:=i$번째 나무까지 가기 위한 최소 피로도로 정의하면, $D[i] = max_{i-K\leq j&lt;i}(D[j] + (H[j]&lt;=H[i]))$ 라는 점화식을 세울 수 있다. 그러나 이는 간단히 계산하면 $O(NK)$가 걸리니, 다른 방법을 생각하자.</p>

<p>우리가 보아야 할 구간이 일정한 간격이 이동하는 형태이므로, deque를 통해 문제를 해결할 수 있다. $D[i]$ 값을 바탕으로 deque 내부를 오름차순으로 유지하자. 구체적으로, $(D[i], H[i])$ pair를 deque에 넣는데 내부가 $D[i]$가 오름차순, $D[i]$가 같으면 $H[i]$가 큰 것을 넣기로 하자. 그렇다면, deque 맨 앞 두 개만 비교해도 $D[i]$의 값을 충분히 구할 수 있음을 알 수 있다.</p>

<p>이와 비슷하게 해결할 수 있는 문제는 <a href="https://www.acmicpc.net/problem/17018">이 문제</a>가 있다.</p>

:ET