I"<h2 id="summary">Summary</h2>
<ul>
  <li>Binary String:</li>
</ul>

<hr />

<h3 id="boj-13894---binary-strings"><a href="https://www.acmicpc.net/problem/13894">BOJ 13894 - Binary Strings</a></h3>
<p>길이가 $n$이고 1이 연속으로 나타나지 않는 문자열의 수는 $f_{n+2}$와 같다. (단, $f_n$은 $n$번째 피보나치 수) 문제는 결국 $f_{K+2}+f_{2K+2}+…$를 빠르게 구하는 것으로, 이는 행렬 거듭제곱을 이용해 해결할 수 있다. 행렬이 모두 2X2 크기이므로 각 테스트케이스마다 $O(\log{N})$에 해결 가능하다.</p>

<h3 id="boj-8131---ploughing"><a href="https://www.acmicpc.net/problem/8131">BOJ 8131 - Ploughing</a></h3>
<p>가장 마지막에 가로줄을 없앤다고 가정하자. 이때 1XK 크기의 가로줄을 마지막에 없애면, K의 크기가 클수록 이득임을 알 수 있다. 이를 위해, 세로선 두 개를 고정하고 위아래 행을 그리디하게 없애자. 그리디하게 행을 제거하면, 남은 위아래 행은 제거 불가능하기 때문에 양 옆 열 중 하나를 제거해야 한다. 이러한 작업을 DP를 이용해 수행하면, 양 옆 열 간격이 줄어들수록 가능한 행 구간이 감소하므로 시간복잡도 $O(NM)$에 해결할 수 있다.</p>

<h3 id="boj-15313---정과프-해적단"><a href="https://www.acmicpc.net/problem/15313">BOJ 15313 - 정과프 해적단</a></h3>
<p>해체기의 범위로 가능한 의미 있는 경우의 수는 $O(N^2)$밖에 없음을 알 수 있다. 이렇게 범위를 지정하고 나면, x좌표 기준으로 정렬한 후 세그먼트 트리를 이용해 LIS를 구하는 것과 비슷하게 $O(N\log{N})$에 모을 수 있는 최대 가치 합을 구할 수 있다.</p>

<p>이렇게 하면 $O(N^3\log{N})$이므로, 좀 더 줄여야 한다. 구간 $[l, r]$이 가치 $M$ 이상을 모을 수 있는 해체기의 구간이라면, 같은 $l$값을 가지는 구간 중 구간 길이가 $r-l+1$보다 큰 구간은 무조건 가치 $M$ 이상을 모을 수 있을 것이다. 이를 이용하면 투 포인터를 사용할 수 있다. 구간의 양쪽이 단조증가하므로, $O(N^2\log{N})$에 전체 문제를 해결할 수 있다.</p>

<h3 id="boj-5820---경주"><a href="https://www.acmicpc.net/problem/5820">BOJ 5820 - 경주</a></h3>
<p>Centroid Decomposition 연습문제로 잘 알려진 문제다. 여기서는 이를 사용하지 않고 해결하는 방법을 설명하겠다.</p>

<p>편의상 1번 정점을 트리의 루트라고 생각하자. 각 정점마다 (높이, 1번 정점으로부터의 거리)를 저장하면, 어떤 정점 $p$와 자식노드 $x, y$에 대해 $x, y$에서 유래하여 $p$를 거치는 경로를 고려해줄 수 있다. $x, y$에는 각 정점이 루트인 서브트리에 대한 모든 정보를 가지고 있다고 가정하면, 작은 집합에서 큰 집합으로 합쳐주는 기법을 이용해 $O(N\log{N})$번의 병합으로 모든 자식노드의 정보를 합쳐줄 수 있다. 정보를 저장할 때에는 <code class="highlighter-rouge">std::map</code>을 이용하면 쉽게 처리할 수 있고, 이때의 시간복잡도는 $O(N\log^2{N})$이다.</p>

<h3 id="boj-17515---maximizer"><a href="https://www.acmicpc.net/problem/17515">BOJ 17515 - Maximizer</a></h3>
<p>문제에서 주어진 식이 최대가 되는 경우는 A를 오름차순으로, B를 내림차순으로 정렬한 상태임을 알 수 있다. 이때 $A_i$가 A에서 작은 절반이고, $B_i$가 B에서 큰 절반이라면 답이 변하지 않고, 이를 이용해 A와 B를 짝지어줄 수 있다. 원소의 개수가 짝수라면 A에서 $[1, {N\over2}]$, B에서 $[{N+1\over2}, N]$를 매칭하면 된다. 홀수 개인 경우는 좀 더 복잡한데, 중간값을 사용하거나 사용하지 않는 경우를 모두 해보고 그 중 최솟값을 찍으면 된다.</p>

<h3 id="boj-11841---biochips"><a href="https://www.acmicpc.net/problem/11841">BOJ 11841 - Biochips</a></h3>
<p>$dp(u, i)$를 $u$번 정점을 루트로 하는 서브트리에서 $i$개를 선택해서 얻을 수 있는 최대 메모리라고 정의하면, 자식노드의 dp값을 이용해 부모노드의 dp값을 채울 수 있다. <a href="https://www.acmicpc.net/problem/12995">이 문제</a>의 요령으로 dp를 돌리면, 시간복잡도 $O(NM)$에 해결할 수 있다.</p>

<hr />
:ET