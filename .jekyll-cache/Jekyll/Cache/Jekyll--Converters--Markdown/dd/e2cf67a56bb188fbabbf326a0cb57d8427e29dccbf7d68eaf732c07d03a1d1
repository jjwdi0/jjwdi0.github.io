I"<hr />

<h3 id="boj-13894---binary-strings"><a href="https://www.acmicpc.net/problem/13894">BOJ 13894 - Binary Strings</a></h3>
<p>길이가 $n$이고 1이 연속으로 나타나지 않는 문자열의 수는 $f_{n+2}$</p>

<h3 id="예선-i-인버스-ㄷㄷㄷㅈ">예선 I. 인버스 ㄷㄷㄷㅈ</h3>
<p>D를 풀고 I를 봤을 때는 쉬워보였는데, 막상 손으로 하나씩 그려보았을 때 잘 그려지지 않았다. 손으로 $n \leq 23$까지 그려보았는데, 팀원이 $n$이 꽤 큰 경우에 대해 ㄷㄷㄷㅈ 트리를 구성하는 방법을 들고 와서 나한테 필요한 케이스를 말해주었고, $n \leq 28$ 범위에 대해 일일히 만들어주어서 해결할 수 있었다. 직접 만들어준 부분이 꽤 길어서 무려 8900B로 AC를 받을 수 있었다. 다른 팀들은 훨씬 간단하게 해결한 것 같은데 우리만의 방식으로(?) 해결한 것 같아서 나름 만족.</p>

<h3 id="본선-a-전단지-돌리기">본선 A. 전단지 돌리기</h3>
<p>ABCD를 담당하기로 해서 문제를 다 읽었는데, 쉬워보이는 문제가 하나도 없었다. 그때 스코어보드에 A 맞은 팀이 우수수 생겨서 바로 A를 잡았고, 간단한 DFS로 풀릴 것 같았다. 모든 정점마다 각 정점이 루트인 서브트리 중 리프까지의 거리의 최댓값을 구해야 했는데, 생각보다 코딩이 까다로웠다. 게다가 시작점이 $S$로 주어지는데 생각없이 1번 정점을 루트로 생각해서 2번이나 틀렸다… 결국에는 21분에 AC.</p>

<h3 id="본선-c-함수-복원">본선 C. 함수 복원</h3>
<p>Functional Graph의 도달 가능성 정보를 주고 원래 그래프의 가짓수를 구하는 문제다. Functional Graph는 최근 푼 문제 중 비슷한 개념이 등장하는 게 있어서 특징을 유추하기 쉬웠고, 약간 헤맨 후 바로 AC를 받을 수 있었다. $n \leq 500$이라 생각없이 $O(n^3)$을 짰는데 $n \leq 5000$ 정도 제한이었다면 최소 D정도 난이도로 올라가지 않았을까 싶다(그랬으면 아마 못 풀거나 몇 번 틀리지 않았을까?).</p>

<h3 id="본선-b-던전-지도">본선 B. 던전 지도</h3>
<p>목적지에서 반대로 간다고 생각하면, 각 행마다 가능한 위치가 구간 형태로 나오며, 이는 단조 감소함을 알 수 있다. <a href="https://www.acmicpc.net/problem/14870">KOI 17 조개 줍기</a> 문제와 유사하다고 느꼈는데, 구간이 단조 감소/증가한다는 점을 파악하는게 훨씬 쉬워서 그런지 생각보다 많은 팀이 해결했다. A에서 말렸지만 B, C를 빠르게 해결해서 이때부터 안정을 찾을 수 있었던 것 같다.</p>

<h3 id="본선-d-소가-길을-건너간-이유-2020">본선 D. 소가 길을 건너간 이유 2020</h3>
<p>문제 이름은 <a href="https://www.acmicpc.net/category/396">USACO 2017 February Contest</a>의 오마주다.</p>

<p>간선을 $N+M-1$개 이으면 전체 그래프는 트리 형태가 되고, 그때의 모든 정점 쌍 간의 거리 합을 최소화하는 것이라 매우 어려울 줄 알았다. 문제를 조금 보다가 두 쪽 정점에 순서를 매겨서, 그 둘을 잇는 간선이 있을 때 전체 트리에서 그 간선을 통과하는 정점 쌍의 개수를 더해주면 해결할 수 있을 것이라는 생각을 했다. 이때 어느 쪽 정점이 연속으로 사용되었는지를 체크하면 되고, 약간 복잡한 $O(NM)$ DP 풀이가 나왔다. 실제로는 한 번 틀렸는데, 처음에는 함수 호출을 이용해 memoization으로 해결하려 해서 TLE를 받았기 때문이었다. 반복문으로 바꾸니까 빠른 시간 안에 해결할 수 있었다.</p>

<h3 id="본선-f-애완-트리">본선 F. 애완 트리</h3>
<p>이 문제랑 I랑 교대로 보면서 고민했는데, I는 직선일 때의 답을 원형에서의 답으로 바꾸려고 시도했는데 잘 안 돼서 F를 중점적으로 고민했다. $f(x)$를 트리의 지름을 $x$ 이하가 되게 하는 경우의 수로 두면, 주어진 문제의 답은 $f(E)-f(S-1)$을 계산하는 것이므로 이 아이디어를 바탕으로 생각을 했다. 이제 트리에서 지름의 길이가 $x$를 넘지 않도록 유지하는 경우의 수를 구해야 했는데, DP를 이용해서 각 정점마다 해당 정점이 서브트리일 때 리프에서의 거리 중 최댓값이 $c$인 경우를 모두 저장했다. 이제 $dp(u, c)$ 값을 이용해 $dp(root, c’)$의 값을 구해야 했는데, 이 부분이 잘 안 돼서 팀원과 오랜 시간 동안 고민을 했다. 이때 될 것 같은 풀이가 나왔고, 20분 정도 구현하고 제출하고 틀리고를 반복해서 대회 종료 약 한 시간 전에 맞을 수 있었다. DP 부분은 침착하게 잘 생각하면 그렇게 오래 걸릴 부분은 아니었던 것 같은데, 이상한 방향으로 생각이 고정되어서(FFT같은 것들이 생각났다…) 시간이 지체된 것 같아서 약간 아쉬웠다.</p>

<hr />
<p>예선 올솔브, 본선 6솔브로 나름 만족스러운 결과였지만, H와 G는 거의 다 풀었는데 못 풀었고, I도 정해와 비슷한 방향으로 생각했지만 시간이 부족해서 못 풀었다는 생각이 들어 아쉽다. H는 xudyh’s sieve를 사용하는 문제였지만, 그걸 짜본 적 있는 팀원과 내가 가진 지식을 합쳤으면 풀 수도 있었으나 그러지 못했다. G도 다른 팀원이 코딩을 했는데 중간에 말려서 제출하지 못했는데, 차라리 단순 코딩을 내가 맡고 I 같은 문제를 맡겼더라면 1~2 솔브 정도는 더 나올 수 있지 않았을까 하는 생각이 든다. 아쉬움도 남지만 뿌듯함도 남는 대회는 처음인 것 같다.</p>

<p>앞으로 남은 SCPC나 ICPC도 열심히 해서 잘 마무리하면 좋겠다!</p>
:ET