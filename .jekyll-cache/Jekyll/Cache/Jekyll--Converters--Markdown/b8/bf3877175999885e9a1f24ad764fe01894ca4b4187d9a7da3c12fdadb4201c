I"(<p>이번 UCPC에 “KMP Algorithm” 팀으로 참가했다. 18년부터 꾸준히 참가해서 세 번째지만, 그간 성적이 만족스럽진 않아서 수상에 대한 기대는 없었다. 결론부터 말하자면, 올해는 운도 좋고 팀원들도 잘 해주어서 11위로 4등상을 받을 수 있었다. 대학에 온 후 PS를 꾸준히 해오면서 대회에서 수상한 적이 없었는데, 이번에 비록 4등상이지만 쟁쟁한 분들이 많이 참가한 대회에서 수상을 하게 되어 감회가 새롭다.</p>

<p>아래는 예선+본선 중 재미있었던 문제를 리뷰하려 한다.</p>

<hr />

<h3 id="예선-d-ㄷㄷㄷㅈ">예선 D. ㄷㄷㄷㅈ</h3>
<p>문제를 보자마자 풀이가 굉장히 많을 것 같은 문제였고, 실제로도 그렇다고 한다. ‘ㅈ’은 정점 하나를 중심으로 세 정점이 이어져 있는 모양이니, 모든 정점에 대해 degree로 $_{n}C_{3}$을 구해주면 된다. ‘ㄷ’은 ‘ㅈ’보다 어려운데, 필자는 각 정점마다 ‘해당 정점을 루트로 하는 서브트리에서, 루트를 포함하는 크기 4인 서브트리의 수’를 구해주었다. 이제 <a href="https://www.acmicpc.net/problem/12995">이 문제</a>와 비슷하게 DP를 돌리고 나서, ‘ㅈ’의 개수를 빼주면 ‘ㄷ’의 개수가 됨을 알 수 있다.</p>

<h3 id="예선-i-인버스-ㄷㄷㄷㅈ">예선 I. 인버스 ㄷㄷㄷㅈ</h3>
<p>D를 풀고 I를 봤을 때는 쉬워보였는데, 막상 손으로 하나씩 그려보았을 때 잘 그려지지 않았다. 손으로 $n \leq 23$까지 그려보았는데, 팀원이 $n$이 꽤 큰 경우에 대해 ㄷㄷㄷㅈ 트리를 구성하는 방법을 들고 와서 나한테 필요한 케이스를 말해주었고, $n \leq 28$ 범위에 대해 일일히 만들어주어서 해결할 수 있었다. 직접 만들어준 부분이 꽤 길어서 무려 8900B로 AC를 받을 수 있었다. 다른 팀들은 훨씬 간단하게 해결한 것 같은데 우리만의 방식으로(?) 해결한 것 같아서 나름 만족.</p>

<h3 id="본선-a-전단지-돌리기">본선 A. 전단지 돌리기</h3>
<p>ABCD를 담당하기로 해서 문제를 다 읽었는데, 쉬워보이는 문제가 하나도 없었다. 그때 스코어보드에 A 맞은 팀이 우수수 생겨서 바로 A를 잡았고, 간단한 DFS로 풀릴 것 같았다. 모든 정점마다 각 정점이 루트인 서브트리 중 리프까지의 거리의 최댓값을 구해야 했는데, 생각보다 코딩이 까다로웠다. 게다가 시작점이 $S$로 주어지는데 생각없이 1번 정점을 루트로 생각해서 2번이나 틀렸다… 결국에는 21분에 AC.</p>

<h3 id="본선-c-함수-복원">본선 C. 함수 복원</h3>
<p>Functional Graph의 도달 가능성 정보를 주고 원래 그래프의 가짓수를 구하는 문제다. Functional Graph는 최근 푼 문제 중 비슷한 개념이 등장하는 게 있어서 특징을 유추하기 쉬웠고, 약간 헤맨 후 바로 AC를 받을 수 있었다. $n \leq 500$이라 생각없이 $O(n^3)$을 짰는데 $n \leq 5000$ 정도 제한이었다면 최소 D정도 난이도로 올라가지 않았을까 싶다(그랬으면 아마 못 풀거나 몇 번 틀리지 않았을까?).</p>

<h3 id="본선-b-던전-지도">본선 B. 던전 지도</h3>
<p>목적지에서 반대로 간다고 생각하면, 각 행마다 가능한 위치가 구간 형태로 나오며, 이는 단조 감소함을 알 수 있다. <a href="https://www.acmicpc.net/problem/14870">KOI 17 조개 줍기</a>문제와</p>

<h3 id="boj-10567---towers">BOJ 10567 - Towers</h3>
<p>모든 경우를 다 만들어 두면 20만 가지 정도가 된다. 이때 모든 행과 열에 대해 몇 개가 보이는지를 먼저 계산해두면 처리하기 쉬워진다. 코딩만 열심히 하면 풀 수 있는 문제.</p>

<h3 id="boj-18313---cave-paintings">BOJ 18313 - Cave Paintings</h3>
<p>아래에서부터 위로 올라가면서 주어진 모양을 트리로 바꿀 것이다. 같은 높이의 비어 있는 공간에 대해, 그보다 아래 높이에 있는 빈 공간을 통해 서로 도달할 수 있으면 같은 정점으로 생각하고, 그렇지 않다면 다른 정점으로 생각하자. 이런 식으로 한 층에서 정점을 만들어주고, 바로 위 층에서 역시 같은 작업을 반복하자. 이제 위아래로 인접한 정점들끼리 간선으로 이어주면 전체 그래프는 forest가 됨을 알 수 있다.</p>

<p>이제 각 트리에서 문제를 해결하자. $u$가 루트인 서브트리에서 painting의 수는, 각 child에서의 경우의 수를 모두 곱한 것에 $u$에 색을 칠하는 횟수인 1을 더한 값으로 생각할 수 있다. 이를 통해 굉장히 간단한 트리 dp를 이용해 전체 답을 구할 수 있다.</p>

<h3 id="boj-13292---dots-and-boxes">BOJ 13292 - Dots and Boxes</h3>
<p>각 $(2i, 2j)$를 정점으로 하는 격자 이분그래프를 생각하자. 이때 소스/싱크에서 각 정점까지의 간선의 용량을 (3 - 막혀 있지 않는 공간의 수)로 두고 플로우를 돌리면 해결할 수 있다.</p>

<hr />
:ET