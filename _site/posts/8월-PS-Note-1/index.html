<!DOCTYPE html>
<html lang="en">
<head><meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">
<link href="https://fonts.googleapis.com/css?family=Nunito+Sans:400,400i,700&display=swap" rel="stylesheet">
<link rel="stylesheet" href="/assets/css/style.css">
<title>8월 PS Note - 1</title>
<!-- Begin Jekyll SEO tag v2.6.1 -->
<title>8월 PS Note - 1 | Programming Notes</title>
<meta name="generator" content="Jekyll v4.0.0" />
<meta property="og:title" content="8월 PS Note - 1" />
<meta name="author" content="Jeong Deokin" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Summary(solved.ac 난이도) Binary String: P4 Ploughing: D3 정과프 해적단: D5 경주: D5 Maximizer: P2 Biochips: P2" />
<meta property="og:description" content="Summary(solved.ac 난이도) Binary String: P4 Ploughing: D3 정과프 해적단: D5 경주: D5 Maximizer: P2 Biochips: P2" />
<link rel="canonical" href="http://localhost:4000/posts/8%EC%9B%94-PS-Note-1/" />
<meta property="og:url" content="http://localhost:4000/posts/8%EC%9B%94-PS-Note-1/" />
<meta property="og:site_name" content="Programming Notes" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2020-08-16T00:00:00+09:00" />
<script type="application/ld+json">
{"url":"http://localhost:4000/posts/8%EC%9B%94-PS-Note-1/","headline":"8월 PS Note - 1","dateModified":"2020-08-16T00:00:00+09:00","datePublished":"2020-08-16T00:00:00+09:00","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/posts/8%EC%9B%94-PS-Note-1/"},"author":{"@type":"Person","name":"Jeong Deokin"},"description":"Summary(solved.ac 난이도) Binary String: P4 Ploughing: D3 정과프 해적단: D5 경주: D5 Maximizer: P2 Biochips: P2","@type":"BlogPosting","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->

  	<script type="text/x-mathjax-config">
	MathJax.Hub.Config({
		TeX: {
		  equationNumbers: {
			autoNumber: "AMS"
		  }
		},
		tex2jax: {
		inlineMath: [ ['$', '$'] ],
		displayMath: [ ['$$', '$$'] ],
		processEscapes: true,
	  }
	});
	MathJax.Hub.Register.MessageHook("Math Processing Error",function (message) {
		  alert("Math Processing Error: "+message[1]);
		});
	MathJax.Hub.Register.MessageHook("TeX Jax - parse error",function (message) {
		  alert("Math Processing Error: "+message[1]);
		});
</script>
<script type="text/javascript" async
	src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML">
</script>
  
</head>
<body>
  <header class="texture-black">
    <div class="container"><div class="navbar">
	<ul>
		<a href="/"><li>Home</li></a>
		<a href="/about/"><li>About</li></a>
	</ul>
</div></div><div class="container">
	<h1>8월 PS Note - 1</h1>
	<h4 class="post-description"></h4>
	<div class="post-date" style="margin-top:20px">
		Published on Aug 16, 2020
	</div>
	<ul class="post-tags"></ul>
</div>
</header>
  <main>
    <div class="container">
      <div class="post-container">
          <h3 id="summarysolvedac-난이도">Summary(solved.ac 난이도)</h3>
<ul>
  <li>Binary String: P4</li>
  <li>Ploughing: D3</li>
  <li>정과프 해적단: D5</li>
  <li>경주: D5</li>
  <li>Maximizer: P2</li>
  <li>Biochips: P2</li>
</ul>

<hr />

<h3 id="boj-13894---binary-strings"><a href="https://www.acmicpc.net/problem/13894">BOJ 13894 - Binary Strings</a></h3>
<p>길이가 $n$이고 1이 연속으로 나타나지 않는 문자열의 수는 $f_{n+2}$와 같다. (단, $f_n$은 $n$번째 피보나치 수) 문제는 결국 $f_{K+2}+f_{2K+2}+…$를 빠르게 구하는 것으로, 이는 행렬 거듭제곱을 이용해 해결할 수 있다. 행렬이 모두 2X2 크기이므로 각 테스트케이스마다 $O(\log{N})$에 해결 가능하다.</p>

<h3 id="boj-8131---ploughing"><a href="https://www.acmicpc.net/problem/8131">BOJ 8131 - Ploughing</a></h3>
<p>가장 마지막에 가로줄을 없앤다고 가정하자. 이때 1XK 크기의 가로줄을 마지막에 없애면, K의 크기가 클수록 이득임을 알 수 있다. 이를 위해, 세로선 두 개를 고정하고 위아래 행을 그리디하게 없애자. 그리디하게 행을 제거하면, 남은 위아래 행은 제거 불가능하기 때문에 양 옆 열 중 하나를 제거해야 한다. 이러한 작업을 DP를 이용해 수행하면, 양 옆 열 간격이 줄어들수록 가능한 행 구간이 감소하므로 시간복잡도 $O(NM)$에 해결할 수 있다.</p>

<h3 id="boj-15313---정과프-해적단"><a href="https://www.acmicpc.net/problem/15313">BOJ 15313 - 정과프 해적단</a></h3>
<p>해체기의 범위로 가능한 의미 있는 경우의 수는 $O(N^2)$밖에 없음을 알 수 있다. 이렇게 범위를 지정하고 나면, x좌표 기준으로 정렬한 후 세그먼트 트리를 이용해 LIS를 구하는 것과 비슷하게 $O(N\log{N})$에 모을 수 있는 최대 가치 합을 구할 수 있다.</p>

<p>이렇게 하면 $O(N^3\log{N})$이므로, 좀 더 줄여야 한다. 구간 $[l, r]$이 가치 $M$ 이상을 모을 수 있는 해체기의 구간이라면, 같은 $l$값을 가지는 구간 중 구간 길이가 $r-l+1$보다 큰 구간은 무조건 가치 $M$ 이상을 모을 수 있을 것이다. 이를 이용하면 투 포인터를 사용할 수 있다. 구간의 양쪽이 단조증가하므로, $O(N^2\log{N})$에 전체 문제를 해결할 수 있다.</p>

<h3 id="boj-5820---경주"><a href="https://www.acmicpc.net/problem/5820">BOJ 5820 - 경주</a></h3>
<p>Centroid Decomposition 연습문제로 잘 알려진 문제다. 여기서는 이를 사용하지 않고 해결하는 방법을 설명하겠다.</p>

<p>편의상 1번 정점을 트리의 루트라고 생각하자. 각 정점마다 (높이, 1번 정점으로부터의 거리)를 저장하면, 어떤 정점 $p$와 자식노드 $x, y$에 대해 $x, y$에서 유래하여 $p$를 거치는 경로를 고려해줄 수 있다. $x, y$에는 각 정점이 루트인 서브트리에 대한 모든 정보를 가지고 있다고 가정하면, 작은 집합에서 큰 집합으로 합쳐주는 기법을 이용해 $O(N\log{N})$번의 병합으로 모든 자식노드의 정보를 합쳐줄 수 있다. 정보를 저장할 때에는 <code class="highlighter-rouge">std::map</code>을 이용하면 쉽게 처리할 수 있고, 이때의 시간복잡도는 $O(N\log^2{N})$이다.</p>

<h3 id="boj-17515---maximizer"><a href="https://www.acmicpc.net/problem/17515">BOJ 17515 - Maximizer</a></h3>
<p>문제에서 주어진 식이 최대가 되는 경우는 A를 오름차순으로, B를 내림차순으로 정렬한 상태임을 알 수 있다. 이때 $A_i$가 A에서 작은 절반이고, $B_i$가 B에서 큰 절반이라면 답이 변하지 않고, 이를 이용해 A와 B를 짝지어줄 수 있다. 원소의 개수가 짝수라면 A에서 $[1, {N\over2}]$, B에서 $[{N+1\over2}, N]$를 매칭하면 된다. 홀수 개인 경우는 좀 더 복잡한데, 중간값을 사용하거나 사용하지 않는 경우를 모두 해보고 그 중 최솟값을 찍으면 된다.</p>

<h3 id="boj-11841---biochips"><a href="https://www.acmicpc.net/problem/11841">BOJ 11841 - Biochips</a></h3>
<p>$dp(u, i)$를 $u$번 정점을 루트로 하는 서브트리에서 $i$개를 선택해서 얻을 수 있는 최대 메모리라고 정의하면, 자식노드의 dp값을 이용해 부모노드의 dp값을 채울 수 있다. <a href="https://www.acmicpc.net/problem/12995">이 문제</a>의 요령으로 dp를 돌리면, 시간복잡도 $O(NM)$에 해결할 수 있다.</p>

<hr />

      </div>

        <!-- Configure Disqus --></div>
  </main><footer class="texture-black">
  <div class="container">
  <h3> 
    &copy;
    2020
    Programming Notes.
  </h3>
</div>
</footer>
</body>
</html>