I"<p>UCPC/ICPC 팀 연습을 몇 번 진행했는데, 셋에 있는 문제를 모두 정리하기에는 아직 모르는 문제도 많아서 아는 문제나 흥미로웠던 문제 위주로 정리하려 한다.</p>

<hr />

<h3 id="2015-tsukuba-regional-i-routing-a-marathon-race">2015 Tsukuba Regional I. Routing a Marathon Race</h3>
<p>$N$이 40이라 플로우 비슷하게 풀리려나 생각했는데, 놀랍게도 백트래킹이 정해다. 단 커팅을 잘 해야 하는데, 현재 위치한 정점 번호 $x$와 현재 정점에 오기 전까지 있었던 정점과 그와 인접한 정점 집합 $Y$를 들고 있자. 만약 최적 경로의 일부분이 $u-v-w$라 하면, $u$와 $w$는 그래프 상에서 연결되어 있을 수 없다. 만약 연결되어 있다면 $u$에서 바로 $w$로 가는 것이 이득이기 때문이다.</p>

<p>이를 이용하면, 정점 $x$에서 다음에 갈 정점을 선택할 때 $y$에 들어있는 정점을 선택하면 절대 최적의 경로를 찾을 수 없음을 알 수 있다. 이를 이용하면 시간 안에 해결할 수 있음을 보장할 수 있다. 시간복잡도를 증명하는 과정이 인상깊다고 생각되어서 이 부분은 직접 해 보는 것을 추천.</p>

<h3 id="2015-tsukuba-regional-j-post-office-investigation">2015 Tsukuba Regional J. Post Office Investigation</h3>
<p>1번 정점에서는 ‘모든 정점을 방문할 수 있고’, 1번 정점에서 $v$번 정점까지 갈 때 ‘반드시 거쳐야 하는 정점’을 구해야 하는 문제다. 이러한 작업을 해 주는 자료구조를 dominator tree라고 한다. 연습 당시에는 몰라서 손도 못 댔는데, dominator tree의 개념을 접하면 문제를 tree에서 LCA를 빠르게 구하는 문제로 바꿀 수 있기 때문에 쉽게 풀린다.</p>

<h3 id="2015-tsukuba-regional-k-min-max-distance-game">2015 Tsukuba Regional K. Min-Max Distance Game</h3>
<p>문제를 결정 문제로 바꿔서 풀자. 구체적으로, 문제를 ‘Alice가 남은 두 돌의 거리를 $x$ 이상으로 남게 할 수 있는가’라는 형태로 바꿔서 생각하자. 이를 쉽게 해결하기 위해 돌의 위치로 그래프를 구성하는데, 두 돌의 거리가 $x$보다 작으면 간선을 이어주는 식으로 만들자. 그러면 두 플레이어는 각 턴마다 정점을 하나 없애면서 그와 연결된 간선을 모두 제거하는 것과 같고, Alice의 경우 그래프의 모든 간선을 지워야 하며 Bob은 반대로 그래프의 간선을 남기는 것을 목적으로 게임을 진행해야 한다.</p>

<p>몇 가지 경우를 살펴보자. 만약 Minimum Vertex Cover의 크기가 Alice가 충분히 지울 정도로 작다면, Alice는 해당 정점만 없애면 이길 수 있다. 그렇지 않고 Maximum Clique의 크기가 Alice가 지울 수 있는 정점의 수보다 크면, Alice는 모든 간선을 지울 수 없으므로 진다. 두 경우가 동시에 발생하는 경우는 없고, 둘 다 발생하지 않는 경우에는 마지막 턴을 진행하는 사람이 이긴다. 그래프가 특수한 형태이므로 Minimum Vertex Cover와 Maximum Clique의 크기는 $O(N)$에 구할 수 있다. 이를 이용하면 빠른 시간 안에 문제를 해결할 수 있다.</p>

<p>위의 내용에 대한 증명은 https://www.slideshare.net/irrrrr/icpc-2015-tsukuba-unofficial-commentary</p>

<h3 id="d-distance-sum">D. Distance Sum</h3>

<h3 id="e-easy-chess">E. Easy Chess</h3>
<p>$n=63$인 경로를 만들고, 중간을 적절히 skip하면 된다.</p>

<h3 id="f-fractions">F. Fractions</h3>
<p>$n$이 서로 다른 두 소인수를 가지면 반드시 문제의 조건을 만족한다. $O(\sqrt{n})$으로 n을 나누는 가장 작은 소인수를 찾고 그것을 $p$라고 하면, $p^k$와 ${n}\over{p^k}$이 서로소가 되도록 $k$를 정해줄 수 있다. 이때 ${n}\over{p^k}$이 1이 아니기만 하면 이 두 수를 분모로 하는 두 분수의 합으로 ${n-1}\over{n}$을 나타낼 수 있다. 두 분모 중 더 작은 값을 분수를 찾아주면 된다.</p>

<h3 id="g-guest-student">G. Guest Student</h3>
<p>이번 셋에서 제일 쉬운 문제.</p>

<h3 id="h-harder-satisfiability">H. Harder Satisfiability</h3>

<h3 id="i-interval-free-permutations">I. Interval-Free Permutations</h3>
<p>풀이를 봤더니 어떻게 되는 지 잘 이해되지는 않았다. 백준에 보니까 0ms로 맞으신 분이 있던데 어떻게 푸신 건지 궁금..</p>

<h3 id="j-js-minification">J. JS Minification</h3>
<p>문제가 좀 끔찍하게 생겨서 안 보고 있었는데 풀만한 문제가 다 떨어져서 끝나기 80분 전쯤에 잡았다. 문제 지문도 길고, 요구하는 것도 많아서 구현까지 20~30분 걸리고, 그 뒤로도 몇 가지 테스트케이스를 넣어 보면서 제출해봤지만 못 맞췄다. 끝나고 다시 풀어봤는데 기존 풀이대로 내면 TLE를 받았겠지만 결과적으로 많이 고치지 않고 AC를 받을 수 있었다. 그냥 쌩으로 구현하는 문제 치고 난이도가 높은 편인 듯. 제발 이런 문제는 안 나왔으면..</p>

<h3 id="k-king-kogs-reception">K. King Kog’s Reception</h3>
<p>공주가 왕을 만나는 시간을 수식으로 잘 표현하는 것이 핵심이다. 이를 알면 문제가 구간 쿼리를 빠르게 계산하는 문제임을 알 수 있고, segment tree와 lazy propagation을 이용해 해결할 수 있다. 대회 때 이 문제를 푼 친구는 정해와 다른 방법으로 푼 것 같은데 그건 나중에 좀 더 고민해 봐야겠다.</p>

<h3 id="l-lazyland">L. Lazyland</h3>
<p>G 다음으로 쉬운 문제.</p>

<h3 id="m-minegraphed">M. Minegraphed</h3>
<p>문제를 보면 어떤 게임이 떠오른다.. 반례 없는 깔끔한 풀이를 만들기 상당히 어려웠고, 맵이 3차원이라 그리기도 어려웠다. 코딩이 복잡할 것 같아서 좀 늦게 잡았는데, 이 문제를 빨리 잡았으면 그래도 문제 한 개 정도는 더 풀었을 것 같다.</p>

<p>주어진 그래프를 SCC들로 분해한 다음, 위상 정렬을 통해 각 SCC가 있어야 할 층을 결정한 후 outgoing edge가 있으면 도달할 수 있도록 길을 열어주고 그렇지 않은 경우 길을 막아주면 된다. 다행이도 맵 크기 제한은 너그러운 편이라 생각보다 쉽게 구현 가능하다.</p>

<hr />
<p>마지막에 J를 풀지 못 한게 너무 아쉬웠다. B도 general matching이 팀노트에 들어갈 것을 생각하면 시도해보지 못한 것도 약간 아쉽다. J나 M같은 구현이 귀찮은 문제를 끈기 있게 잡고 푸는 연습을 해야 할 듯.</p>
:ET