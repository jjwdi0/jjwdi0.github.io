I"<p>이번 UCPC에 “KMP Algorithm” 팀으로 참가했다. 18년부터 꾸준히 참가해서 세 번째지만, 그간 성적이 만족스럽진 않아서 수상에 대한 기대는 없었다. 결론부터 말하자면, 올해는 운도 좋고 팀원들도 잘 해주어서 11위로 4등상을 받을 수 있었다. 대학에 온 후 PS를 꾸준히 해오면서 대회에서 수상한 적이 없었는데, 이번에 비록 4등상이지만 쟁쟁한 분들이 많이 참가한 대회에서 수상을 하게 되어 감회가 새롭다.</p>

<p>아래는 예선+본선 중 재미있었던 문제를 리뷰하려 한다.</p>

<hr />

<h3 id="예선-d-ㄷㄷㄷㅈ">예선 D. ㄷㄷㄷㅈ</h3>
<p>문제를 보자마자 풀이가 굉장히 많을 것 같은 문제였고, 실제로도 그렇다고 한다. ‘ㅈ’은 정점 하나를 중심으로 세 정점이 이어져 있는 모양이니, 모든 정점에 대해 degree로 $_{n}C_{3}$을 구해주면 된다.</p>

<h3 id="2015-tsukuba-regional-j-post-office-investigation">2015 Tsukuba Regional J. Post Office Investigation</h3>
<p>1번 정점에서는 ‘모든 정점을 방문할 수 있고’, 1번 정점에서 $v$번 정점까지 갈 때 ‘반드시 거쳐야 하는 정점’을 구해야 하는 문제다. 이러한 작업을 해 주는 자료구조를 dominator tree라고 한다. 연습 당시에는 몰라서 손도 못 댔는데, dominator tree의 개념을 접하면 문제를 tree에서 LCA를 빠르게 구하는 문제로 바꿀 수 있기 때문에 쉽게 풀린다.</p>

<h3 id="2015-tsukuba-regional-k-min-max-distance-game">2015 Tsukuba Regional K. Min-Max Distance Game</h3>
<p>문제를 결정 문제로 바꿔서 풀자. 구체적으로, 문제를 ‘Alice가 남은 두 돌의 거리를 $x$ 이상으로 남게 할 수 있는가’라는 형태로 바꿔서 생각하자. 이를 쉽게 해결하기 위해 돌의 위치로 그래프를 구성하는데, 두 돌의 거리가 $x$보다 작으면 간선을 이어주는 식으로 만들자. 그러면 두 플레이어는 각 턴마다 정점을 하나 없애면서 그와 연결된 간선을 모두 제거하는 것과 같고, Alice의 경우 그래프의 모든 간선을 지워야 하며 Bob은 반대로 그래프의 간선을 남기는 것을 목적으로 게임을 진행해야 한다.</p>

<p>몇 가지 경우를 살펴보자. 만약 Minimum Vertex Cover의 크기가 Alice가 충분히 지울 정도로 작다면, Alice는 해당 정점만 없애면 이길 수 있다. 그렇지 않고 Maximum Clique의 크기가 Alice가 지울 수 있는 정점의 수보다 크면, Alice는 모든 간선을 지울 수 없으므로 진다. 두 경우가 동시에 발생하는 경우는 없고, 둘 다 발생하지 않는 경우에는 마지막 턴을 진행하는 사람이 이긴다. 그래프가 특수한 형태이므로 Minimum Vertex Cover와 Maximum Clique의 크기는 $O(N)$에 구할 수 있다. 이를 이용하면 빠른 시간 안에 문제를 해결할 수 있다.</p>

<p>위의 내용에 대한 증명은 <a href="https://www.slideshare.net/irrrrr/icpc-2015-tsukuba-unofficial-commentary">https://www.slideshare.net/irrrrr/icpc-2015-tsukuba-unofficial-commentary</a>에서 확인할 수 있다.</p>

<h3 id="boj-10562---나이트">BOJ 10562 - 나이트</h3>
<p>$M$이 작고 $N$이 굉장히 크다. $M$을 고정하면 답이 점화식의 형태로 구해질 것이라 추측할 수 있고, 실제로도 맞다. 이전 두 열이 결정되면 가능한 다음 열의 상태를 구할 수 있으니 이를 이용하면 행렬 곱셈으로 문제를 해결할 수 있다. 이 경우 $O(2^{6M}\log{N})$ 시간복잡도로 구할 수 있다.</p>

<p>행렬로 점화식을 계산할 수 있으니, Berlekamp-Massey Algorithm을 적용할 수 있다. 초기 값들은 bitmask dp를 이용해 구할 수 있으니, 이를 이용하면 시간복잡도를 개선할 수 있다. 실제로 BOJ에서는 0ms로 통과할 수 있다.</p>

<h3 id="boj-10566---도장-도장">BOJ 10566 - 도장 도장</h3>
<p>도장을 두 번째로 찍을 때 첫 번째로 찍을 때와 비교해서 움직인 좌표를 벡터 $(a, b)$로 두자. 그럼 각 점에 대해서 $(a, b)$만큼 움직였을 때 해당 점에 이미 도장이 찍혀있거나, 만약 그렇지 않다면 $-(a, b)$만큼 움직인 곳에 도장이 찍혀있어야 한다. 두 조건 모두 만족하지 않는다면 그때의 $(a, b)$는 올바르지 않은 벡터가 되고, 도장이 찍힌 모든 점이 두 조건 중 하나를 만족하면 $(a, b)$는 답의 후보가 될 수 있다. 각 가능한 $(a, b)$마다 초기 도장의 위치로 가능한 점의 수를 세어서 그 중 최솟값을 구하면 된다. 이렇게 문제를 해결하려 하면 $O(W^2L^2)$의 시간복잡도가 되어 TLE를 받을 것이다.</p>

<p>여기서 주어진 점들의 convex hull을 고려하자. 이때 첫 도장에 포함되어 있고 그 점이 두 번째 도장으로 옮겨 가는 점 두 개가 모두 convex hull에 있는 점이 있다. 이를 이용해 convex hull 상에서 구할 수 있는 $(a, b)$들만 답의 후보로 추릴 수 있고, 이러한 벡터들로만 시도하면 AC를 받을 수 있다.</p>

<h3 id="boj-10567---towers">BOJ 10567 - Towers</h3>
<p>모든 경우를 다 만들어 두면 20만 가지 정도가 된다. 이때 모든 행과 열에 대해 몇 개가 보이는지를 먼저 계산해두면 처리하기 쉬워진다. 코딩만 열심히 하면 풀 수 있는 문제.</p>

<h3 id="boj-18313---cave-paintings">BOJ 18313 - Cave Paintings</h3>
<p>아래에서부터 위로 올라가면서 주어진 모양을 트리로 바꿀 것이다. 같은 높이의 비어 있는 공간에 대해, 그보다 아래 높이에 있는 빈 공간을 통해 서로 도달할 수 있으면 같은 정점으로 생각하고, 그렇지 않다면 다른 정점으로 생각하자. 이런 식으로 한 층에서 정점을 만들어주고, 바로 위 층에서 역시 같은 작업을 반복하자. 이제 위아래로 인접한 정점들끼리 간선으로 이어주면 전체 그래프는 forest가 됨을 알 수 있다.</p>

<p>이제 각 트리에서 문제를 해결하자. $u$가 루트인 서브트리에서 painting의 수는, 각 child에서의 경우의 수를 모두 곱한 것에 $u$에 색을 칠하는 횟수인 1을 더한 값으로 생각할 수 있다. 이를 통해 굉장히 간단한 트리 dp를 이용해 전체 답을 구할 수 있다.</p>

<h3 id="boj-13292---dots-and-boxes">BOJ 13292 - Dots and Boxes</h3>
<p>각 $(2i, 2j)$를 정점으로 하는 격자 이분그래프를 생각하자. 이때 소스/싱크에서 각 정점까지의 간선의 용량을 (3 - 막혀 있지 않는 공간의 수)로 두고 플로우를 돌리면 해결할 수 있다.</p>

<hr />
:ET